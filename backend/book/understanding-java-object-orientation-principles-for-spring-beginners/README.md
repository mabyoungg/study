# [스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://www.yes24.com/Product/Goods/17350624)

---

## 목차
- [1. 사람을 사랑한 기술](#1-사람을-사랑한-기술)
- [2. 자바와 절차적/구조적 프로그래밍](#2-자바와-절차적구조적-프로그래밍)
- [3. 자바와 객체 지향](#3-자바와-객체-지향)
- [4. 자바가 확장한 객체 지향](#4-자바가-확장한-객체-지향)

---

### 1. 사람을 사랑한 기술
2) 기계어에서 객체 지향 프로그래밍 언어로
   - 기계어 코드는 CPU에 따라 다르다
   - 어셈블리: 기계어 명령어와 일상 용어 일대일 매칭하는 코드표
   - 어셈블러: 어셈블리어를 기계어로 번역해 주는 소프트웨어
   - C: One Source Multi Object Use Anywhere
   - C++: C 언어에 객체 지향 프로그래밍 기능 추가
   - Java: Write Once Use Anywhere
   - CBD: Component Based Development, 컴포넌트 기반 개발
   - SOA: Service Oriented Architecture, 서비스 지향 아키텍처
   - 스프링을 지배하는 근원적 요소가 있는데 바로 스프링 삼각형이라고 하는 IoC/DI, AOP, PSA
   - 스프링 삼각형은 POJO(Plain Old Java Object)에 세 가지 유형의 진동을 줌으로써 거대한 프레임워크를 완성
   - 기계어, 어셈블리어, C 언어, 자바 비교

<div style="margin-left: 40px;">

|            | 기계어      | 어셈블리어               | C 언어                   | 자바                                         |
|------------|----------|---------------------|------------------------|--------------------------------------------|
| 개발자의 코딩    | 0과 1의 나열 | 일상 단어 사용            | 수학적 기호 사용              | 수학적 기호 사용                                  |
| 소스 파일      | 기종마다 하나씩 | 기종마다 하나씩            | 기종이 몇 개든 단 하나          | 기종이 몇 개든 단 하나                              |
| 목적 파일(기계어) | 소스 그 자체  | 어셈블러로 기계어 생성        | 컴파일러로 해당 운영체제용 기계어 생성  | 기종이 몇 개든 단 하나의 JVM용 기계어 생성                 |
| 기계어 비교     |          | 기계어와 1 : 1 대응하는 니모닉 | 기계어와 m : n 대응하는 수학적 기호 | 기계어와 m : n 대응하는 수학적 기호                     |
| 비고         |          | 기종별 어셈블러 필요         | 기종별 컴파일러 필요            | 단 하나의 컴파일러만 필요, 기종별 JRE 세팅 필요(한번만 설치해주면 됨) |

</div>


---

### 2. 자바와 절차적/구조적 프로그래밍
1) 자바 프로그램의 개발과 구동
   - JDK: Java Development Kit, 자바 개발 키트
   - JRE: Java Runtime Environment, 자바 실행 환경
   - JVM: Java Virtual Machine, 자바 가상 머신
   - 객체 지향 프로그램의 메모리 사용 방식: 코드 실행 영역, 데이터 저장 영역(스태틱 영역, 스택 영역, 힙 영역)


3) 다시 보는 main() 메서드: 메서드 스택 프레임
   - JRE는 먼저 프로그램 안 main() 메서드 확인 -> JVM 부팅 -> 목적 파일 로드 -> java.lang 패키지 스태틱 영역 로드 -> 개발자가 작성한 모든 클래스와 임포트 패키지 스태틱 영역 로드 ->  main() 메서드 스택 프레임을 스택 영역 할당 -> args 변수 공간 할당 -> main() 메서드 명령문 실행 -> main() 메서드 종료 -> main() 메서드 스택 프레임 소멸 -> JRE는 JVM 종료 후 JRE 자체도 운영체제 상의 메모리에서 소멸


6) 지역 변수와 메모리: 스택 프레임에 갇혔어요!
   - 스태틱 영역: 클래스 놀이터, 클래스 정보 저장, 클래스 변수 저장
   - 스택 영역: 메서드 놀이터, 메서드 호출 시 생성되는 지역 변수 저장
   - 힙 영역: 객체 놀이터, 객체 멤버 변수 저장
   - 내부 스택 프레임 변수에서 외부 스택 프레임 변수 접근 가능


8) 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
   - 스택 프레임에 종속적인 지역 변수
   - 스택 프레임에 독립적인 전역 변수
   - 전역 변수는 피해야 한다. 전역 상수는 추천.


9) 멀티 스레드 / 멀티 프로세스의 이해
   - 멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할, 하나의 스레드에서 다른 스레드의 스택 영역 접근은 불가능하지만 스태틱 영역과 힙 영역은 공유, 멀티 프로세스 대비 메모리 적게 사용
   - 멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조, 하나의 프로세스가 다른 프로세스의 T 메모리 영역이 접근 불가능 해 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다


11) 정리 - 객체 지향은 절차적/구조적 프로그램의 어깨를 딛고
    - 메서드를 만들 때는 순서도 또는 의사 코드 작성, 능력이 된다면 UML 액티비어 다이어그램, 메서드 로직을 표현할 때는 순서도가 더 직관적
    - NS 다이어그램 추천

---

### 3. 자바와 객체 지향
1) 객체 지향은 인간 지향이다


2) 객체 지향의 4대 특성 - 캡! 상추다
   - 캡슐화(Encapsulation): 정보 은닉
   - 상속(~~Inheritance~~): 재사용
   - 추상화(Abstraction): 모델링
   - 다형성(Polymorphism): 사용 편의

  
4) 추상화: 모델링
   - 객체: 세상에서 존재하는 유일무이한 사물
   - 클래스: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
   - 추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것 = 모델링
   - 클래스 멤버 = static 멤버 = 정적 멤버
   - 객체 멤버 = 인스턴스 멤버
   - 유틸리티성 메서드를 주로 정적 메서드로 구성
   - 클래스 속성과 객체 속성은 별도의 초기화를 하지 않으면 기본값으로 초기화, 지역 변수는 초기화 해줘야 함
   - 세 가지 변수 유형
<div style="margin-left: 40px;">

| 이름        | 다른 이름                      | 사는 곳(T 메모리) |
|-----------|----------------------------|-------------|
| static 변수 | 클래스 [멤버] 속성, 정적 변수, 정적 속성  | 스태틱 영역      |
| 인스턴스 변수   | 객체 [멤버] 속성, 객체 변수          | 힙 영역        |
| local 변수  | 지역 변수                      | 스택 영역       |

</div>


5) 상속: 재사용 + 확장
   - 상위 클래의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미
   - 상속의 개념이 조직도나 계층도가 아닌 분류도
   - 하위 클래스는 상위 클래스다
   - 클래스명은 클래스답게 분류스럽게, 객체 참조 변수명은 객체답게 유일무이한 사물처럼
   - 객체 지향의 상속은 상위 클래스의 특성을 재사용, 확장, is a kind of 관계를 만족
   - 다중 상속 다이아몬드 문제: 상위 클래스가 여러 개일 때 하위 클래스가 어떤 상위 클래스의 메서드를 호출해야 할지 모호한 문제
   - 자바는 다중 상속을 지원하지 않음, 인터페이스를 통해 다중 상속을 대체
   - 인터페이스: be able to, 다중 상속을 지원
   - 상위 클래스는 풍성할수록 좋고(LSP, 리스코프 치환 원칙), 인터페이스는 메서드가 적을수록 좋다(ISP, 인터페이스 분할 원칙)
   - 힙 영역에 하위 클래스의 인스턴스 생성 될 때 상위 클래스의 인스턴스도 함께 생성


6) 다형성: 사용 평의성
   - 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 하위 클래스에서 재정의
   - 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
   - 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다


7) 캡슐화: 정보 은닉
   - 접근 제어자 
     - public: 모든 패키지에서 접근 가능
     - protected: 상속 / 같은 패키지 내의 클래스에서 접근 가능
     - default: 같은 패키지 내의 클래스에서 접근 가능
     - private: 같은 클래스 내에서만 접근 가능
     - private인 경우 같은 클래스의 객체 끼리는 서로 접근 가능
   - 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객채 참조 변수를 이용해 접근
   - 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장


- 참조 변수의 복사
  - 기본 자료형 변수는 값을 값 자체로 판단
  - 참조 자료형 변수는 값을 주소, 즉 포인터로 판단
  - 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 즉 가지고 있는 값을 그대로 복사해서 넘겨 준다

---

### 4. 자바가 확장한 객체 지향
1) abstract 키워드 - 추상 메서드와 추상 클래스
   - 추상 메서드 없이도 추상 클래스 선언 가능
   - 추상 클래스느 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다
   - 추상 메서드는 하위 클래스에서 메서드의 구현을 강제한다. 오버라이딩 강제
   - 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다


2) 생성자
   - 객체 생성자 메서드
   - 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 생성
   - 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성사를 만들지 않음


3) 클래스 생성 시의 실행 블록, static 블록
   - 프로그램이 시작될때 모든 패키지와 모든 클래스가 T 메모리 스태틱 영역에 로딩된다고 했으나, 실제로는 해당 패키지 또는 클래스가 처음 사용 될 때 로딩
   - 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리 스태틱 영역에 로딩, 이때 단 한번 해당 클래스의 static 블록 실행
     - 클래스의 정적 속성을 사용할 때
     - 클래스의 정적 메서드를 사용할 때
     - 클래스의 인스턴스를 최초로 만들 때
   - 인스턴스 블록은 아무런 표시 없이 { } 블록을 사용, 인스턴스 생성 시마다 실행, 객체 생성자가 실행되기 전에 먼저 실행


4) final 키워드
   - final 클래스: 상속 금지
   - final 변수: 상수, 한 번 초기화하면 값을 변경할 수 없다
   - final 메서드: 오버라이딩 금지
   
  
5) instanceof 연산자
   - 객체가 특정 클래스의 인스턴스인지 확인하는 연산자
   - LSP(리스코프 치환 원칙)를 어기는 코드에서 주로 나타남


6) package 키워드
   - 네임스페이스를 만들어주는 역할
   - 패키지는 클래스를 분류하는 단위


7) interface 키워드와 implements 키워드
   - public 추상 메서드와 public 정적 상수만 가질 수 있다
   - 메서드에 public과 abstract, 속성에 public과 static, final이 자동으로 붙는다
   - 자바 8부터 default 메서드와 static 메서드를 가질 수 있다


8) this 키워드
   - 객체가 자기 자신을 지칭할 때 쓰는 키워드
   - 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선
   - 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용
   - 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용


9) super 키워드
   - 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드
   - 상위의 상위 클래스의 인스턴스는 접근 불가능


10) 예비 고수를 위한 한마디
    - 객체 멤버 메서드를 힙 영역에 여러 개 보유하면 메모리 낭비, 스태틱 영역에 단 하나만 보유, 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘김

---