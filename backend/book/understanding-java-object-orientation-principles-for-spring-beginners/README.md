# [스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://www.yes24.com/Product/Goods/17350624)

---

## 목차
- [1. 사람을 사랑한 기술](#1-사람을-사랑한-기술)
- [2. 자바와 절차적/구조적 프로그래밍](#2-자바와-절차적구조적-프로그래밍)
- [3. 자바와 객체 지향](#3-자바와-객체-지향)
- [4. 자바가 확장한 객체 지향](#4-자바가-확장한-객체-지향)
- [5. 객체 지향 설계 5원칙 - SOLID](#5-객체-지향-설계-5원칙---solid)
- [6. 스프링이 사랑한 디자인 패턴](#6-스프링이-사랑한-디자인-패턴)
- [7. 스프링 삼각형과 설정 정보](#7-스프링-삼각형과-설정-정보)
- [A. 스프링 MVC를 이용한 게시판 구축](#a-스프링-mvc를-이용한-게시판-구축)
- [B. 자바 8 람다와 인터페이스 스펙 변화](#b-자바-8-람다와-인터페이스-스펙-변화)

---

### 1. 사람을 사랑한 기술
2) 기계어에서 객체 지향 프로그래밍 언어로
   - 기계어 코드는 CPU에 따라 다르다
   - 어셈블리: 기계어 명령어와 일상 용어 일대일 매칭하는 코드표
   - 어셈블러: 어셈블리어를 기계어로 번역해 주는 소프트웨어
   - C: One Source Multi Object Use Anywhere
   - C++: C 언어에 객체 지향 프로그래밍 기능 추가
   - Java: Write Once Use Anywhere
   - CBD: Component Based Development, 컴포넌트 기반 개발
   - SOA: Service Oriented Architecture, 서비스 지향 아키텍처
   - 스프링을 지배하는 근원적 요소가 있는데 바로 스프링 삼각형이라고 하는 IoC/DI, AOP, PSA
   - 스프링 삼각형은 POJO(Plain Old Java Object)에 세 가지 유형의 진동을 줌으로써 거대한 프레임워크를 완성
   - 기계어, 어셈블리어, C 언어, 자바 비교

<div style="margin-left: 40px;">

|            | 기계어      | 어셈블리어               | C 언어                   | 자바                                         |
|------------|----------|---------------------|------------------------|--------------------------------------------|
| 개발자의 코딩    | 0과 1의 나열 | 일상 단어 사용            | 수학적 기호 사용              | 수학적 기호 사용                                  |
| 소스 파일      | 기종마다 하나씩 | 기종마다 하나씩            | 기종이 몇 개든 단 하나          | 기종이 몇 개든 단 하나                              |
| 목적 파일(기계어) | 소스 그 자체  | 어셈블러로 기계어 생성        | 컴파일러로 해당 운영체제용 기계어 생성  | 기종이 몇 개든 단 하나의 JVM용 기계어 생성                 |
| 기계어 비교     |          | 기계어와 1 : 1 대응하는 니모닉 | 기계어와 m : n 대응하는 수학적 기호 | 기계어와 m : n 대응하는 수학적 기호                     |
| 비고         |          | 기종별 어셈블러 필요         | 기종별 컴파일러 필요            | 단 하나의 컴파일러만 필요, 기종별 JRE 세팅 필요(한번만 설치해주면 됨) |

</div>


---

### 2. 자바와 절차적/구조적 프로그래밍
1) 자바 프로그램의 개발과 구동
   - JDK: Java Development Kit, 자바 개발 키트
   - JRE: Java Runtime Environment, 자바 실행 환경
   - JVM: Java Virtual Machine, 자바 가상 머신
   - 객체 지향 프로그램의 메모리 사용 방식: 코드 실행 영역, 데이터 저장 영역(스태틱 영역, 스택 영역, 힙 영역)


3) 다시 보는 main() 메서드: 메서드 스택 프레임
   - JRE는 먼저 프로그램 안 main() 메서드 확인 -> JVM 부팅 -> 목적 파일 로드 -> java.lang 패키지 스태틱 영역 로드 -> 개발자가 작성한 모든 클래스와 임포트 패키지 스태틱 영역 로드 ->  main() 메서드 스택 프레임을 스택 영역 할당 -> args 변수 공간 할당 -> main() 메서드 명령문 실행 -> main() 메서드 종료 -> main() 메서드 스택 프레임 소멸 -> JRE는 JVM 종료 후 JRE 자체도 운영체제 상의 메모리에서 소멸


6) 지역 변수와 메모리: 스택 프레임에 갇혔어요!
   - 스태틱 영역: 클래스 놀이터, 클래스 정보 저장, 클래스 변수 저장
   - 스택 영역: 메서드 놀이터, 메서드 호출 시 생성되는 지역 변수 저장
   - 힙 영역: 객체 놀이터, 객체 멤버 변수 저장
   - 내부 스택 프레임 변수에서 외부 스택 프레임 변수 접근 가능


8) 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
   - 스택 프레임에 종속적인 지역 변수
   - 스택 프레임에 독립적인 전역 변수
   - 전역 변수는 피해야 한다. 전역 상수는 추천.


9) 멀티 스레드 / 멀티 프로세스의 이해
   - 멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할, 하나의 스레드에서 다른 스레드의 스택 영역 접근은 불가능하지만 스태틱 영역과 힙 영역은 공유, 멀티 프로세스 대비 메모리 적게 사용
   - 멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조, 하나의 프로세스가 다른 프로세스의 T 메모리 영역이 접근 불가능 해 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다


11) 정리 - 객체 지향은 절차적/구조적 프로그램의 어깨를 딛고
    - 메서드를 만들 때는 순서도 또는 의사 코드 작성, 능력이 된다면 UML 액티비어 다이어그램, 메서드 로직을 표현할 때는 순서도가 더 직관적
    - NS 다이어그램 추천

---

### 3. 자바와 객체 지향
1) 객체 지향은 인간 지향이다


2) 객체 지향의 4대 특성 - 캡! 상추다
   - 캡슐화(Encapsulation): 정보 은닉
   - 상속(~~Inheritance~~): 재사용
   - 추상화(Abstraction): 모델링
   - 다형성(Polymorphism): 사용 편의

  
4) 추상화: 모델링
   - 객체: 세상에서 존재하는 유일무이한 사물
   - 클래스: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
   - 추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것 = 모델링
   - 클래스 멤버 = static 멤버 = 정적 멤버
   - 객체 멤버 = 인스턴스 멤버
   - 유틸리티성 메서드를 주로 정적 메서드로 구성
   - 클래스 속성과 객체 속성은 별도의 초기화를 하지 않으면 기본값으로 초기화, 지역 변수는 초기화 해줘야 함
   - 세 가지 변수 유형
<div style="margin-left: 40px;">

| 이름        | 다른 이름                      | 사는 곳(T 메모리) |
|-----------|----------------------------|-------------|
| static 변수 | 클래스 [멤버] 속성, 정적 변수, 정적 속성  | 스태틱 영역      |
| 인스턴스 변수   | 객체 [멤버] 속성, 객체 변수          | 힙 영역        |
| local 변수  | 지역 변수                      | 스택 영역       |

</div>


5) 상속: 재사용 + 확장
   - 상위 클래의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미
   - 상속의 개념이 조직도나 계층도가 아닌 분류도
   - 하위 클래스는 상위 클래스다
   - 클래스명은 클래스답게 분류스럽게, 객체 참조 변수명은 객체답게 유일무이한 사물처럼
   - 객체 지향의 상속은 상위 클래스의 특성을 재사용, 확장, is a kind of 관계를 만족
   - 다중 상속 다이아몬드 문제: 상위 클래스가 여러 개일 때 하위 클래스가 어떤 상위 클래스의 메서드를 호출해야 할지 모호한 문제
   - 자바는 다중 상속을 지원하지 않음, 인터페이스를 통해 다중 상속을 대체
   - 인터페이스: be able to, 다중 상속을 지원
   - 상위 클래스는 풍성할수록 좋고(LSP, 리스코프 치환 원칙), 인터페이스는 메서드가 적을수록 좋다(ISP, 인터페이스 분할 원칙)
   - 힙 영역에 하위 클래스의 인스턴스 생성 될 때 상위 클래스의 인스턴스도 함께 생성


6) 다형성: 사용 평의성
   - 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 하위 클래스에서 재정의
   - 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
   - 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다


7) 캡슐화: 정보 은닉
   - 접근 제어자 
     - public: 모든 패키지에서 접근 가능
     - protected: 상속 / 같은 패키지 내의 클래스에서 접근 가능
     - default: 같은 패키지 내의 클래스에서 접근 가능
     - private: 같은 클래스 내에서만 접근 가능
     - private인 경우 같은 클래스의 객체 끼리는 서로 접근 가능
   - 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객채 참조 변수를 이용해 접근
   - 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장


- 참조 변수의 복사
  - 기본 자료형 변수는 값을 값 자체로 판단
  - 참조 자료형 변수는 값을 주소, 즉 포인터로 판단
  - 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 즉 가지고 있는 값을 그대로 복사해서 넘겨 준다

---

### 4. 자바가 확장한 객체 지향
1) abstract 키워드 - 추상 메서드와 추상 클래스
   - 추상 메서드 없이도 추상 클래스 선언 가능
   - 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다
   - 추상 메서드는 하위 클래스에서 메서드의 구현을 강제한다. 오버라이딩 강제
   - 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다


2) 생성자
   - 객체 생성자 메서드
   - 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 생성
   - 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성사를 만들지 않음


3) 클래스 생성 시의 실행 블록, static 블록
   - 프로그램이 시작될때 모든 패키지와 모든 클래스가 T 메모리 스태틱 영역에 로딩된다고 했으나, 실제로는 해당 패키지 또는 클래스가 처음 사용 될 때 로딩
   - 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리 스태틱 영역에 로딩, 이때 단 한번 해당 클래스의 static 블록 실행
     - 클래스의 정적 속성을 사용할 때
     - 클래스의 정적 메서드를 사용할 때
     - 클래스의 인스턴스를 최초로 만들 때
   - 인스턴스 블록은 아무런 표시 없이 { } 블록을 사용, 인스턴스 생성 시마다 실행, 객체 생성자가 실행되기 전에 먼저 실행


4) final 키워드
   - final 클래스: 상속 금지
   - final 변수: 상수, 한 번 초기화하면 값을 변경할 수 없다
   - final 메서드: 오버라이딩 금지
   
  
5) instanceof 연산자
   - 객체가 특정 클래스의 인스턴스인지 확인하는 연산자
   - LSP(리스코프 치환 원칙)를 어기는 코드에서 주로 나타남


6) package 키워드
   - 네임스페이스를 만들어주는 역할
   - 패키지는 클래스를 분류하는 단위


7) interface 키워드와 implements 키워드
   - public 추상 메서드와 public 정적 상수만 가질 수 있다
   - 메서드에 public과 abstract, 속성에 public과 static, final이 자동으로 붙는다
   - 자바 8부터 default 메서드와 static 메서드를 가질 수 있다


8) this 키워드
   - 객체가 자기 자신을 지칭할 때 쓰는 키워드
   - 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선
   - 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용
   - 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용


9) super 키워드
   - 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드
   - 상위의 상위 클래스의 인스턴스는 접근 불가능


10) 예비 고수를 위한 한마디
    - 객체 멤버 메서드를 힙 영역에 여러 개 보유하면 메모리 낭비, 스태틱 영역에 단 하나만 보유, 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘김

---

### 5. 객체 지향 설계 5원칙 - SOLID
1) SRP - 단일 책임 원칙
   - Single Responsibility Principle
   - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 한다
   - 클래스는 단 하나의 책임을 가져야 한다
   - 클래스가 여러 책임을 가지면 클래스를 변경할 때 다른 책임에 영향을 줄 수 있다
   - 클래스를 변경할 때 다른 클래스에 영향을 주지 않도록 하기 위해 단일 책임 원칙을 지키는 것이 좋다


2) OCP - 개방 폐쇄 원칙
   - Open Closed Principle
   - 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다
   - 소프트웨어 엔티티(클랫, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다


3) LSP - 리스코프 치환 원칙
   - Liskov Substitution Principle
   - 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다
   - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다
   - 하위형에서 선행 조건을 강화될 수 없다
   - 하위형에서 후행 조건을 약화할 수 없다
   - 하위형에서 상위형의 불편 조건은 반드시 유지돼야 한다


4) ISP - 인터페이스 분리 원칙
   - Interface Segregation Principle
   - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
   - 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책
   - 인터페이스 최소주의 원칙


5) DIP - 의존 역전 원칙
   - Dependency Inversion Principle
   - 자신보다 변하기 쉬운 것에 의존하지 마라
   - 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다
   - 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다
   - 자주 변경되는 구체 클래스에 의존하지 마라


6) 정리 - 객체 지향 세계와 SOLID
   - SoC: Separation of Concerns, 관심사의 분리, 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것

---

### 6. 스프링이 사랑한 디자인 패턴
1) 어댑터 패턴(Adapter Pattern)
   - 객체를 속성으로 만들어서 참조하는 디자인 패턴
   - 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴


2) 프록시 패턴(Proxy Pattern)
   - 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다
   - 대리자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
   - 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다
   - 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다
   - 제어의 흐름을 변경하거나 별도의 로직 처리를 목적으로 한다
   - 클라이언트가 받는 반한값을 특별한 경우가 아니라면 변경하지 않는다
   - 개방 폐쇄 원칙과 의존 역전 원칙이 적용된 설계 패턴
   - 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴


3) 데코레이터 패턴(Decorator Pattern)
   - 클라이언트가 받는 반환값에 장식을 더한다
   - 반환값에 장식을 더한다는 것을 빼면 프록시 패턴과 동일
   - 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다
   - 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
   - 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 반환값에 장식을 더해 클라이언트에게 돌려준다
   - 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다
   - 개방 폐쇄 원칙과 의존 역전 원칙이 적용된 설계 패턴
   - 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴


4) 싱글턴 패턴(Singleton Pattern)
   - 인스턴스를 하나만 만들어 사용하기 위한 패턴
   - private 생성자를 갖는다(new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다)
   - 단일 객체 참조 변수를 정적 속성으로 갖는다(유일한 단일 객체를 참조할 정적 참조 변수가 필요하다)
   - 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다(유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요하다)
   - 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다
   - 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴


5) 템플릿 메서드 패턴(Template Method Pattern)
   - 상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상메서드 또는 선택적으로 오버라딩할 수 있는 Hook 메서드를 두는 패턴
   - 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴


6) 팩터리 메서드 패턴(Factory Method Pattern)
   - 하위 클래스에서 팩터리 메서드를 오버라이딩해서 객체를 반환하게 하는 것
   - 오버라이드된 메서드가 객체를 반환하는 패턴


7) 전략 패턴(Strategy Pattern)
   - 디자인 패턴의 꽃
   - 전략 메서드를 가진 전략 객체
   - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
   - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)
   - 단일 상속만이 가능한 자바 언어에서는 상속이라는 제한이 있는 템플릿 메서드 패턴보다는 전략 패턴이 더 많이 활용
   - 개방 폐쇄 원칙과 의존 역전 원칙이 적용된 설계 패턴
   - 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴


8) 템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)
   - 전략 패턴의 변형, DI(의존성 주입)에서 사용하는 특별한 형태의 전략 패턴
   - 전략 패턴과 모든 것이 동일한데 전략을 익명 내부 클래스로 정의해서 사용한다는 특징
   - 개방 폐쇄 원칙과 의존 역전 원칙이 적용된 설계 패턴
   - 전략을 익명 내부 클래스로 구현한 전략 패턴


9) 스프링이 사랑한 다른 패턴들
   - 스프링은 다양한 디자인 패턴을 활용
   - 스프링 MVC 경우 프론트 컨트롤러 패턴(Front Controller Pattern: 최전선 제어자 패턴), MVC 패턴(Model - View - Controller) 활용

---

### 7. 스프링 삼각형과 설정 정보
1) IoC/DI - 제어의 역전/의존성 주입
   - IoC: Inversion of Control, 제어의 역전
   - DI: Dependency Injection, 의존성 주입
   - 프로그래밍에서 의존 관계는 new로 표현된다
   - 집합 관계: 부분이 전체와 다른 생명 주기를 가질 수 있다
   - 구성 관계: 부분은 전체와 같은 생명 주기를 갖는다
   - 최근에는 속성을 통한 의존성 주입보다는 생성자를 통한 의존성 주입을 선호하는 사람들이 많다, 프로그램에서는 한번 주입된 의존성을 계속 사용하는 경우가 더 일반적이기 때문
   - 스프링 없이 의존성 주입
     - 생성자, 속성
   - 스프링을 통한 의존성 주입
     - XML 파일, XML 파일에 속성 주입, @Autowired (id 매칭보다 type 매칭 우선, 스프링 어노테이션), @Resource (type 매칭보다 id 매칭 우선, 자바 표준 어노테이션)
     - @Autowired와 @Qualifier를 조합해서 사용, @Resource에서 id가 필드 이름과 다른 빈을 이용해 속성 주입하기, 자바 어노테이션 표준인 JSR-250, JSR-330
   - @Autowired와 @Resource 중에서는 @Resource 추천, 프레임워크 교체시 유리
   - @Resource와 \<property\> 중에서는 \<property\> 추천, 유지보수성이 좋다
   - 프로젝트 규모와 팀의 성향에 맞는 방법을 선택하는 것이 중요
   - 설정 파일을 쓰는 가장 중요한 이유가 재컴파일/재배포 없이 프로그램의 실행 결과를 변경할 수 있다
   - 의존 관계가 new라고 단순화했지만 사실 변수에 값을 할당하는 모든 곳에 의존 관계가 생김
   - DI는 외부에 있는 의존 대상을 주입하는 것
   - 의존 대상을 구현하고 배치할 때 SOLID와 응집도는 높이고 결합도는 낮추라는 기본 원칙에 충실해야 한다, 그래야 프로젝트의 구현과 유지보수가 수월
   
<div style="margin-left: 40px;">

|             | @Autowired                                              | @Resource                  |
|-------------|---------------------------------------------------------|----------------------------|
| 출처          | 스프링 프레임워크                                               | 표준 자바                      |
| 소속패키지       | org.springframework.beans.factory.annotation.Autowired  | javax.annotation.Resource  |
| 빈 검색 방식     | byType 먼저, 못 찾으면 byName                                 | byName 먼저, 못 찾으면 byType    |
| 특이사항        | @Qualifier("") 협업                                       | name 어트리뷰트                 |
| byName 강제하기 | @Autowired, @Qualifier("tire")                          | @Resource(name = "tire")   |

</div>


2) AOP - Aspect? 관점? 핵심 관심사? 횡단 관심사?
   - Aspect-Oriented Programming, 관점 지향 프로그래밍
   - 스프링 DI가 의존성에 대한 주입이라면 스프링 AOP는 로직 주입
   - 횡단 관심사: cross-cutting concern, 다수의 모듈에 공통적으로 나타나는 부분
   - 핵심 관심사: core concern, 각 모듈의 핵심적인 부분, 모듈별로 다름
   - 코드 = 핵심 관심사 + 횡단 관심사
   - @Aspect 어노테이션을 사용해 Aspect 클래스를 만들고, @Before, @After, @Around, @AfterReturning, @AfterThrowing 어노테이션을 사용해 횡단 관심사를 구현, JoinPoint 객체를 사용해 핵심 관심사에 접근
   - CGLiB: Code Generation Library, 인터페이스가 없는 클래스에 대한 프록시를 만들 때 사용, 코드를 변경할 수 없는 서드파티 모듈 안에 final로 선언된 클래스에 AOP를 적용해야 하는 경우 사용
   - 컴퓨터 세상에는 다양한 프록시 사용, 버퍼도 일종의 프록시, 네트워크 속도를 향상시키는 캐시서버도 프록시, 존재 목적은 다르지만 하는 역할은 모두 중간에서 가로채는 것이라는 동일한 일을 한다
   - 스프링 AOP
     - 인터페이스 기반이다
     - 프록시 기반이다
     - 런타임 기반이다
   - Pointcut: Aspect 적용 위치 지정자, 횡단 관심사를 적용할 타깃 메서드를 선택하는 지시자(메서드 선택 필터), 타깃 클래스의 타깃 메서드 지정자
     - 정규식, AspectJ 표현식 사용 가능
     - [접근제한자패턴] 리턴타입패턴 [패키지&클래스패턴] 메서드이름패턴(파라미터패턴) [throws 예외패턴], 대괄호는 생략 가능
   - JoinPoint: 연결 가능한 지점, 스프링 프레임워크가 관리하는 빈의 모든 메서드
     - JoinPoint 파리미터를 이용하면 실행 시점에 실제 호출된 메서드, 실제 호출된 메서드를 소유한 객체, 호출된 메서드의 파라미터 등의 정보를 확인 가능
     - 광의의 JoinPoint란 Aspect 적용이 가능한 모든 지점
     - 협의의 JoinPoint란 호출된 객체의 메서드
   - Advice: Pointcut에 언제, 무엇을 적용할지 정의한 메서드, 타깃 객체의 타깃 메서드에 적용될 부가 기능
   - Aspect: 여러 개의 Advice와 여러 개의 Pointcut의 결합체, Aspect = Advice들 + Pointcut들
   - Advisor: 한 개의 Advice + 한 개의 Pointcut, 스프링 AOP에서만 사용하는 용어이며 버전이 올라가면서 쓰지 말라고 권고하는 기능, 스프링이 발전해 오면서 다수의 Advice와 다수의 Pointcut을 다양하게 조합해서 사용할 수 있는 방법, 즉 Aspect가 나왔기 때문


3) PSA - 일관성 있는 서비스 추상화
   - Portable Service Abstraction, 일관성 있는 서비스 추상화
   - 서비스 추상화: 어댑터 패턴을 적용해 같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할 수 있게 한 것
   - OXM(Object XML Mapping: 객체와 XML 매핑) 기술만 하더라도 JAXB, Castor, JiBX, XStream 등 다양한 기술이 있는데 이 다양한 기술들이 제공하는 API는 제각각이다. 스프링은 제각각인 API를 위한 어댑터를 제공함으로써 실제로 어떤 OXM 기술을 쓰든 일관된 방식으로 코드를 작성할 수 있게 지원하고 하나의 OXM 기술에서 다른 OXM 기술로 변경할 때 큰 변화 없이 세부 기술을 교체해서 사용할 수 있게 해줌. 이처럼 서비스 추상화를 해주면서 그것도 일관성 있는 방식을 제공한다고 해서 이를 PSA라고 한다
   - 스프링은 OXM뿐만 아니라 ORM, 캐시, 트랜잭션 등 다양한 기술에 대한 PSA 제공

---

### A. 스프링 MVC를 이용한 게시판 구축
7) 새 글 구현
   - PRG 패턴: POST-Redirect-GET 패턴, 사용자 경험을 개선하고 데이터 중복 제출을 방지하기 위해 설계, 새 글 등록 후 새 글 상세 화면으로 이동할 때 브라우저의 새로고침으로 인한 중복 등록을 방지하기 위한 패턴


8) 수정 구현
   - MVC 컨트롤러에 `@SessionAttributes("Session에 저장할 객체명)` 특정 모델 속성을 세션에 저장하고 재사용
   - 세션에 저장한 객체를 활용하는 메서드의 인자에 `@ModelAttribute("Session에 저장한 객체명")` 지정
   - SessionStatus 객체의 setComplete() 메서드를 사용해 세션에 저장된 객체를 삭제

---

### B. 자바 8 람다와 인터페이스 스펙 변화
1) 람다가 도입된 이유
   - 주된 이유 기업 환경 변화, 프로그래머들의 요구
     - 빅데이터의 분석 및 활용
     - 병렬화를 위해 컬렉션 강화 -> 스트림 강화 -> 함수형 프로그래밍 -> 람다 -> 인터페이스 명세 변경 -> 함수형 인터페이스 도입


2) 람다란 무엇인가?
   - `(인자 목록) -> {로직}`, 로직이 단 한줄로 표기되는 경우 중괄호 생략 가능, 인자가 하나이고 자료형일 표기하지 않는 경우 소괄호 생략 가능
   - 코드 블록, 변수처럼 사용
   - 메서드 호출 인자, 메서드 반환값으로 사용 가능


3) 함수형 인터페이스
   - 추상 메서드를 하나만 갖는 인터페이스, `@FunctionalInterface` 어노테이션을 사용해 함수형 인터페이스임을 명시
   - `(int a) -> { return a * a; }` -> `(a) -> { return a * a; }` -> `a -> { return a * a; }` -> ` a -> a * a`


6) 자바 8 API에서 제공하는 함수형 인터페이스
   - 대표적 함수 인터페이스 목록
<div style="margin-left: 40px;">

| 함수형 인터페이스           | 추상 메서드                 | 용도                          |
|---------------------|------------------------|-----------------------------|
| Runnable            | void run()             | 실행할 수 있는 인터페이스              |
| Supplier<T>         | T get()                | 제공할 수 있는 인터페이스              |
| Consumer<T>         | void accept(T t)       | 소비할 수 있는 인터페이스              |
| Function<T, R>      | R apply(T t)           | 입력을 받아서 출력할 수 있는 인터페이스      |
| Predicate<T>        | Boolean test(T t)      | 입력을 받아 참/거짓을 단정할 수 있는 인터페이스 |
| UnaryOperator<T>    | T apply(T t)           | 단항(Unary) 연산할 수 있는 인터페이스    |
| BiConsumer<T, U>    | void accept(T t, U u)  | 이항(Binary) 소비자 인터페이스        |
| BiFunction<T, U, R> | R apply(T t, U u)      | 이항 함수 인터페이스                 |
| BiPredicate<T, U>   | Boolean test(T t, U u) | 이항 단정 인터페이스                 |
| BinaryOperator<T>   | T apply(T t, T t)      | 이항 연산 인터페이스                 |

</div>


7) 컬렉션 스트림에서 람다 사용
   - 함수형 프로그래밍의 장점인 선언적 프로그래밍 활용
   - 메서드 체인 패턴을 이용해 최종 연산이 아닌 모든 중간 연산은 다시 스트림을 반환해 코드를 간략하게 작성할 수 있게 지원


8) 메서드 레퍼런스와 생성자 레퍼런스
   - 메서드 래퍼런스 
      - 인스턴스::인스턴스메서드
      - 클래스::정적메서드
      - 클래스::인스턴스메서드
   - 생성자 레퍼런스
     - 클래스명::new


9) 인터페이스의 디폴트 메서드와 정적 메서드
   - 구체 인스턴스 메서드 - 디폴드 메서드
   - (구체) 정적 메서드
   - 인터페이스에 변화를 주게 되면, 기존에 해당 인터페이스를 구현한 모든 사용자 정의 클래스는 이를 추가적으로 구현해야 한다, 이를 방지하기 위해 디폴트 메서드와 정적 메서드를 도입


10) 정리
    - 람다 = 변수에 저장 가능한 로직
    - 기존의 자바 로직은 메서드를 통해 구현, 더 이상 로직을 메서드의 체계, 즉 객체 메서드나 정적 메서드 안에 구현하지 않아도 된다
    - 병렬 스트림을 지원하는 컬렉션에서 stream() 메서드 대신 parallelStream() 메서드를 사용하면 스트림 작업을 병렬 처리 가능

---