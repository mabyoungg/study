# [모두를 위한 컴퓨터 과학 (CS50 2019)](https://www.boostcourse.org/cs112)

---

## 목차
- [1. 컴퓨팅 사고](#1-컴퓨팅-사고)
- [2. C언어](#2-c언어)
- [3. 배열](#3-배열)
- [4. 알고리즘](#4-알고리즘)
- [5. 메모리](#5-메모리)
- [6. 자료구조](#6-자료구조)

---

[CS50 IDE](https://cs50.dev/)  
[CS50 라이브러리](https://github.com/cs50/libcs50)  
[CS50 라이브러리 문서](https://cs50.readthedocs.io/libraries/cs50/c/)

---

### 1. 컴퓨팅 사고
1) 2진법
   - 2진법은 0과 1로 이루어진 숫자 체계
   - 비트(bit) : 2진법에서 하나의 자릿수를 표현하는 단위
   - 바이트(byte) : 8비트를 의미
   - 2진법 체계(Birany)
<div style="margin-left: 40px;">

| 단위             | 정의         |
|----------------|------------|
| bit            | 0 또는 1     |
| byte           | 8 bits     |
| Kibibyte (KiB) | 1024 bytes |
| Mebibyte (MiB) | 1024 KiB   | 
| Gibibyte (GiB) | 1024 MiB   |
| Tebibyte (TiB) | 1024 GiB   |

   *10진법 체계(Decimal)에서는 kilobyte (kB) = 1000 bytes 등으로 정의*

</div>

2) 정보의 표현
   - ASCII (아스키코드/American Standard Code for Information Interchange)
      - 7비트로 표현되는 문자 인코딩 체계
      - 128개의 문자를 표현
      - 0 ~ 127까지의 숫자로 표현
      - 0 ~ 31, 127번은 제어문자(Control Characters)로 사용
      - 32 ~ 126번은 출력 가능한 문자
      - 97번은 소문자 'a', 65번은 대문자 'A'로 표현
      - 소문자는 같은 대문자 글자보다 항상 2<sup>5</sup> 만큼 큼
      - 확장 ASCII는 8번째 비트를 추가하여 총 256개의 문자를 표현
   - Unicode (유니코드)
      - 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준
      - 100만개 이상의 문자를 나타낼 수 있는 문자 인코딩 표준
   - RGB (Red, Green, Blue)
      - 색을 표현하는 방법
      - 0 ~ 255까지의 숫자로 표현
      - 0은 해당 색의 최소, 255는 해당 색의 최대
      - (255, 0, 0)은 빨간색, (0, 255, 0)은 초록색, (0, 0, 255)은 파란색

<div style="margin-left: 50px;">
   <details>
      <summary>아스키코드 표</summary>

   | 2진수 (Binary)  | 10진수 (Dec) | 16진수 (Hex) | 문자 (Character) | 설명 (Description) |
   |---------------|------------|------------|----------------|---------------------|
   | 00000000      | 0          | 00         | NUL            | Null character      |
   | 00000001      | 1          | 01         | SOH            | Start of Header     |
   | 00000010      | 2          | 02         | STX            | Start of Text       |
   | 00000011      | 3          | 03         | ETX            | End of Text         |
   | 00000100      | 4          | 04         | EOT            | End of Transmission |
   | 00000101      | 5          | 05         | ENQ            | Enquiry             |
   | 00000110      | 6          | 06         | ACK            | Acknowledgment      |
   | 00000111      | 7          | 07         | BEL            | Bell                |
   | 00001000      | 8          | 08         | BS             | Backspace           |
   | 00001001      | 9          | 09         | HT             | Horizontal Tab      |
   | 00001010      | 10         | 0A         | LF             | Line Feed (New Line) |
   | 00001011      | 11         | 0B         | VT             | Vertical Tab        |
   | 00001100      | 12         | 0C         | FF             | Form Feed (New Page) |
   | 00001101      | 13         | 0D         | CR             | Carriage Return     |
   | 00001110      | 14         | 0E         | SO             | Shift Out           |
   | 00001111      | 15         | 0F         | SI             | Shift In            |
   | 00010000      | 16         | 10         | DLE            | Data Link Escape    |
   | 00010001      | 17         | 11         | DC1            | Device Control 1    |
   | 00010010      | 18         | 12         | DC2            | Device Control 2    |
   | 00010011      | 19         | 13         | DC3            | Device Control 3    |
   | 00010100      | 20         | 14         | DC4            | Device Control 4    |
   | 00010101      | 21         | 15         | NAK            | Negative Acknowledgment |
   | 00010110      | 22         | 16         | SYN            | Synchronous Idle    |
   | 00010111      | 23         | 17         | ETB            | End of Transmission Block |
   | 00011000      | 24         | 18         | CAN            | Cancel              |
   | 00011001      | 25         | 19         | EM             | End of Medium       |
   | 00011010      | 26         | 1A         | SUB            | Substitute          |
   | 00011011      | 27         | 1B         | ESC            | Escape              |
   | 00011100      | 28         | 1C         | FS             | File Separator      |
   | 00011101      | 29         | 1D         | GS             | Group Separator     |
   | 00011110      | 30         | 1E         | RS             | Record Separator    |
   | 00011111      | 31         | 1F         | US             | Unit Separator      |
   | 00100000      | 32         | 20         | (Space)        | Space               |
   | 00100001      | 33         | 21         | !              | Exclamation mark    |
   | 00100010      | 34         | 22         | "              | Double quote        |
   | 00100011      | 35         | 23         | #              | Number sign         |
   | 00100100      | 36         | 24         | $              | Dollar sign         |
   | 00100101      | 37         | 25         | %              | Percent sign        |
   | 00100110      | 38         | 26         | &              | Ampersand           |
   | 00100111      | 39         | 27         | '              | Single quote        |
   | 00101000      | 40         | 28         | (              | Left parenthesis    |
   | 00101001      | 41         | 29         | )              | Right parenthesis   |
   | 00101010      | 42         | 2A         | *              | Asterisk            |
   | 00101011      | 43         | 2B         | +              | Plus sign           |
   | 00101100      | 44         | 2C         | ,              | Comma               |
   | 00101101      | 45         | 2D         | -              | Hyphen-minus        |
   | 00101110      | 46         | 2E         | .              | Period              |
   | 00101111      | 47         | 2F         | /              | Slash               |
   | 00110000      | 48         | 30         | 0              | Digit 0             |
   | 00110001      | 49         | 31         | 1              | Digit 1             |
   | 00110010      | 50         | 32         | 2              | Digit 2             |
   | 00110011      | 51         | 33         | 3              | Digit 3             |
   | 00110100      | 52         | 34         | 4              | Digit 4             |
   | 00110101      | 53         | 35         | 5              | Digit 5             |
   | 00110110      | 54         | 36         | 6              | Digit 6             |
   | 00110111      | 55         | 37         | 7              | Digit 7             |
   | 00111000      | 56         | 38         | 8              | Digit 8             |
   | 00111001      | 57         | 39         | 9              | Digit 9             |
   | 00111010      | 58         | 3A         | :              | Colon               |
   | 00111011      | 59         | 3B         | ;              | Semicolon           |
   | 00111100      | 60         | 3C         | <              | Less-than sign      |
   | 00111101      | 61         | 3D         | =              | Equals sign         |
   | 00111110      | 62         | 3E         | >              | Greater-than sign   |
   | 00111111      | 63         | 3F         | ?              | Question mark       |
   | 01000000      | 64         | 40         | @              | At sign             |
   | 01000001      | 65         | 41         | A              | Uppercase A         |
   | 01000010      | 66         | 42         | B              | Uppercase B         |
   | 01000011      | 67         | 43         | C              | Uppercase C         |
   | 01000100      | 68         | 44         | D              | Uppercase D         |
   | 01000101      | 69         | 45         | E              | Uppercase E         |
   | 01000110      | 70         | 46         | F              | Uppercase F         |
   | 01000111      | 71         | 47         | G              | Uppercase G         |
   | 01001000      | 72         | 48         | H              | Uppercase H         |
   | 01001001      | 73         | 49         | I              | Uppercase I         |
   | 01001010      | 74         | 4A         | J              | Uppercase J         |
   | 01001011      | 75         | 4B         | K              | Uppercase K         |
   | 01001100      | 76         | 4C         | L              | Uppercase L         |
   | 01001101      | 77         | 4D         | M              | Uppercase M         |
   | 01001110      | 78         | 4E         | N              | Uppercase N         |
   | 01001111      | 79         | 4F         | O              | Uppercase O         |
   | 01010000      | 80         | 50         | P              | Uppercase P         |
   | 01010001      | 81         | 51         | Q              | Uppercase Q         |
   | 01010010      | 82         | 52         | R              | Uppercase R         |
   | 01010011      | 83         | 53         | S              | Uppercase S         |
   | 01010100      | 84         | 54         | T              | Uppercase T         |
   | 01010101      | 85         | 55         | U              | Uppercase U         |
   | 01010110      | 86         | 56         | V              | Uppercase V         |
   | 01010111      | 87         | 57         | W              | Uppercase W         |
   | 01011000      | 88         | 58         | X              | Uppercase X         |
   | 01011001      | 89         | 59         | Y              | Uppercase Y         |
   | 01011010      | 90         | 5A         | Z              | Uppercase Z         |
   | 01011011      | 91         | 5B         | [              | Left square bracket |
   | 01011100      | 92         | 5C         | \              | Backslash           |
   | 01011101      | 93         | 5D         | ]              | Right square bracket |
   | 01011110      | 94         | 5E         | ^              | Caret (Circumflex accent) |
   | 01011111      | 95         | 5F         | _              | Underscore          |
   | 01100000      | 96         | 60         | `              | Grave accent        |
   | 01100001      | 97         | 61         | a              | Lowercase a         |
   | 01100010      | 98         | 62         | b              | Lowercase b         |
   | 01100011      | 99         | 63         | c              | Lowercase c         |
   | 01100100      | 100        | 64         | d              | Lowercase d         |
   | 01100101      | 101        | 65         | e              | Lowercase e         |
   | 01100110      | 102        | 66         | f              | Lowercase f         |
   | 01100111      | 103        | 67         | g              | Lowercase g         |
   | 01101000      | 104        | 68         | h              | Lowercase h         |
   | 01101001      | 105        | 69         | i              | Lowercase i         |
   | 01101010      | 106        | 6A         | j              | Lowercase j         |
   | 01101011      | 107        | 6B         | k              | Lowercase k         |
   | 01101100      | 108        | 6C         | l              | Lowercase l         |
   | 01101101      | 109        | 6D         | m              | Lowercase m         |
   | 01101110      | 110        | 6E         | n              | Lowercase n         |
   | 01101111      | 111        | 6F         | o              | Lowercase o         |
   | 01110000      | 112        | 70         | p              | Lowercase p         |
   | 01110001      | 113        | 71         | q              | Lowercase q         |
   | 01110010      | 114        | 72         | r              | Lowercase r         |
   | 01110011      | 115        | 73         | s              | Lowercase s         |
   | 01110100      | 116        | 74         | t              | Lowercase t         |
   | 01110101      | 117        | 75         | u              | Lowercase u         |
   | 01110110      | 118        | 76         | v              | Lowercase v         |
   | 01110111      | 119        | 77         | w              | Lowercase w         |
   | 01111000      | 120        | 78         | x              | Lowercase x         |
   | 01111001      | 121        | 79         | y              | Lowercase y         |
   | 01111010      | 122        | 7A         | z              | Lowercase z         |
   | 01111011      | 123        | 7B         | {              | Left curly brace    |
   | 01111100      | 124        | 7C         | \|             | Vertical bar        |
   | 01111101      | 125        | 7D         | }              | Right curly brace   |
   | 01111110      | 126        | 7E         | ~              | Tilde               |
   | 01111111      | 127        | 7F         | DEL            | Delete              |

   </details>
</div>

3) 알고리즘 (Algorithm)
    - 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행되어야 하는지에 대한 규칙들의 순서적 나열
    - 정확성 : 알고리즘이 올바른 결과를 내는지 평가하는 척도
    - 효율성 : 알고리즘의 성능을 평가하는 척도
    - 의사코드 (Pseudo code) : 컴퓨터가 수행할 작업을 프로그램 언어가 아니라 사람이 사용하는 언어로 알고리즘의 논리적 절차를 작성한 코드
   

4) 스크래치: 기초
    - MIT에서 개발한 블록형 프로그래밍 언어
    - 블록을 조립하여 프로그램을 만들 수 있음
    - 알고리즘을 구성하는 요소로는 함수, 조건, 불리언 표현, 루프 등이 있음
   

5) 스크래치: 심화
   - 변수 : 데이터를 저장하는 공간
   - 조건문 : 조건에 따라 다른 명령을 수행

---

### 2. C언어
1) C 기초
   - C는 아주 오래되고 전통적인 순수 텍스트 기반 프로그래밍 언어 
   - 소스코드: 사람이 작성한 프로그램 코드
   - 머신코드: 컴퓨터가 이해할 수 있는 0과 1로 이루어진 코드
   - 컴파일러 (Compiler) : 소스 코드를 머신 코드(기계어)로 번역하는 프로그램
   - `clang -o hello hello.c` : hello.c 파일을 컴파일하여 hello라는 이름의 실행 파일을 생성
   - `./hello` : hello 실행 파일을 실행
   - 리눅스 파일 시스템 명령어: `ls, rm, cp, mv, mkdir, rmdir` 등
   - `ls` 명령어 입력 후 파일명에 `*` 붙어 있으면 실행가능한 머신코드, `/`폴더
   - `hello, world` 출력 C 프로그램 구조
     ```c
     #include <stdio.h>
     
     int main(void)
     {
         printf("hello, world\n");
     }
      ```
     
2) 문자열
   - CS50 라이브러리 활용한 string 입력, 출력
   - `-l`: 컴파일 시에 라이브러리를 링크하는 옵션
   - `make`: 소스 코드를 자동으로 컴파일하고 빌드하여 실행 파일을 생성하는 도구


3) 조건문과 루프
   - 조건문: 특정 코드가 특정 상황에서만 실행되도록 하는 구문
   - if, else if, else, while, for, switch 등의 조건문과 루프 사용
   - 삼항 연산자: `(a > b) ? a : b;`
   - 코드를 간결하게 만들어 효율적으로 코딩, 적은 메모리, CPU를 사용해서 수행하는지 중요


4) 자료형, 형식 지정자, 연산자
   - 데이터 타입: bool, char, string, int, long, float, double
   - 형식 지정자: %c, %f, %i, %li, %s 등
   - 기타 연산자 및 주석 : +, -, *, /, %, &&, ||, // 등
   - %.2f: 소수점 둘째 자리까지 출력
   - 읽기 편하고 이해하기 쉬운 코드 선호


5) 사용자 정의 함수, 중첩 루프
   - 사용자 정의 함수 장점: 코드의 재사용성, 코드의 가독성, 코드의 유지보수성 


6) 하드웨어의 한계
   - RAM (Random Access Memory): 컴퓨터의 물리적 저장장치, 모든 프로그램이 실행 중 저장되는 곳
   - 오버플로우 (Overflow): 변수가 표현할 수 있는 범위를 넘어서는 값을 저장하려고 할 때 발생하는 오류
   - 부동 소수점 부정확성, 정수 오버플로우, 메모리 제한 등의 문제가 발생
   - Y2K 버그, 보잉 787 소프트웨어 버그로 인한 추락 사고 등의 문제가 발생
   - 프로그램 설계시 적절한 데이터 타입 선택, 일정 주기 메모리 초기화, 미래 지향적 설계 등의 방법으로 해결
   - figlet: ASCII 문자로 이루어진 문자열 출력 프로그램

---

### 3. 배열
1) 컴파일링
   - preprocessing -> compiling -> assembling -> linking
   - preprocessing: #include, #define, #ifdef, #endif 등의 전처리기 지시어를 처리
   - compiling: 소스 코드를 어셈블리 코드로 변환
   - assembling: 어셈블리 코드를 머신코드로 변환
   - linking: 여러 개의 다른 머신 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합치고 실행 파일로 변환


2) 디버깅
   - bug: 코드에 들어있는 오류
   - debugging: 프로그램의 버그를 식별하고 고치는 과정
   - debugger: 프로그램의 버그를 찾아내는 도구, 특정 행에서 프로그램이 어떻게 동작하는지 확인 가능
   - Grace Hopper: 컴퓨터 과학의 선구자, 프로그램 버그 개념 창시자, 최초 컴파일러 개발
   - help50, debug50: CS50 디버깅 도구
   - gdb: GNU 디버거, 리눅스 환경에서 사용 가능한 디버깅 도구


3) 코드의 디자인
   - check50, style50: CS50 코드의 정확도, 스타일을 분석하는 도구
   - 코드의 가독성, 유지보수성, 확장성을 고려한 코드 디자인이 중요
   - rubber duck debugging: 코드 디버깅 방법, rubber duck 등 대상을 두고 문제를 설명하는 과정에서 해결책을 찾게 되는 방법
   - [CS50 Style Guide](https://cs50.readthedocs.io/style/c/)


4) 배열(1)
   - 배열: 값들의 리스트, 같은 자료형의 데이터를 메모리상에 연이어서 저장하고 이를 하나의 변수로 관리
   - 배열의 인덱스는 0부터 시작, 인덱스를 통해 배열의 요소에 접근 가능
   - 배열의 크기는 고정되어 있으며 한 번 정해지면 변경 불가

<div style="margin-left: 40px;">

| 타입     | 크기      | 설명       |
|--------|---------|----------|
| bool   | 1 byte  | 불리언      |
| char   | 1 byte  | 문자       |
| int    | 4 bytes | 정수       |
| float  | 4 bytes | 실수       |
| long   | 8 bytes | (더 큰) 정수 |
| float  | 8 bytes | (더 큰) 실수 |
| string | ?       | 문자열      |

</div>

5) 배열(2)
   - const 키워드: 변수를 상수로 선언, 값 변경 불가, 변수명 대문자 표기
   - 전역 변수: 프로그램 전체에서 사용 가능한 변수, 함수 밖에서 선언
   - 함수 프로토타입: 함수의 선언부를 미리 정의, 컴파일러에게 함수의 존재와 해당 함수의 매개변수, 반환형에 대해 알리는 역할
   - C언어의 배열은 스스로의 길이를 기억하지 않음
   

6) 문자열과 배열
   - 문자열: 문자들의 배열, 문자열의 끝에는 널 종단 문자('\0')가 포함되어 있음, 글자수 + 1 byte 만큼의 메모리 공간 필요
   - 널 종단 문자(null-terminator): 문자열이 끝났고 더 이상의 문자가 남아있지 않다고 말하는 문자


7) 문자열의 활용
   - 대문자와 소문자 사이의 ASCII 코드 차이 32
     - [ASCII Table](https://www.asciitable.com/)
     - 대문자에서 소문자 -32, 소문자에서 대문자 +32
   - string.h, ctype.h 등 헤더 파일 사용
     - [CS50 Manual Pages](https://manual.cs50.io/)
     - strlen: 문자열의 길이를 반환하는 함수
     - toupper, tolower: 대문자, 소문자로 변환하는 함수


8) 명령행 인자
   - 명령행 인자: 프로그램 실행 시 프로그램에 전달하는 인자
   - main 함수의 매개변수로 int argc, string argv[]를 사용
   - argc: 명령행 인자의 개수, argv[]: 명령행 인자의 배열
   - `./argv 1 2 3` 실행 시 argc = 4, argv[0] = "./argv", argv[1] = "1", argv[2] = "2", argv[3] = "3"
   - main 함수의 반환값: 프로그램의 종료 상태를 나타내는 값, 0은 성공, 그 외 숫자 실패 또는 오류

---

### 4. 알고리즘
1) 검색 알고리즘
   - 선형 검색(Linear Search): 배열이나 리스트에서 처음부터 끝까지 하나씩 순차적으로 비교하면서 원하는 값을 찾는 방법
   - 이진 검색(Binary Search): 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반씩 줄여가며 원하는 값을 찾는 방법


2) 알고리즘 표기법
   - Big O 표기법: 최악의 경우에 대한 성능을 표기하는 방법, 알고리즘을 수행하는데 필요한 시간의 상한선을 의미
   - Big Omega(Ω) 표기법: 최선의 경우에 대한 성능을 표기하는 방법
   - 실행시간의 상한이 낮은 알고리즘이 더 좋음


3) 선형 검색
   - 정확하지만 아주 효율적이지 못한 방법
   - 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우 유용
   - 정렬은 시간이 오래 걸리고 공간을 더 차지한다. 하지만 정렬을 진행하면 여러 번 리스트를 검색하거나 매우 큰 리스트를 검색해야 할 경우 시간 단축 가능
   - typedef struct: 구조체를 정의하고, 새로운 타입 이름 부여
     ```c
       typedef struct {
           string name;
           string number;
       } person;
     ```
     

4) 버블 정렬
   - Bubble Sort: 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
   - 상한 O(n<sup>2</sup>), 하한 Ω(n<sup>2</sup>)
   - 구현이 쉬우나 시간 복잡도가 높아 큰 데이터에 대해 비효율적

   
5) 선택 정렬
   - Selection Sort: 배열 안의 자료 중 가작 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치의 수(혹은 가장 마지막 위치)와 교환해주는 방식으로 정렬
   - 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수 증가
   - 상한 O(n<sup>2</sup>), 하한 Ω(n<sup>2</sup>)


6) 정렬 알고리즘의 실행시간
   - 버블 정렬은 교환이 없을때 알고리즘을 종료하면 하한 Ω(n)의 시간 복잡도를 가짐
   - [정렬 알고리즘 시각화](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)
   - [Big O Cheat Sheet](https://www.bigocheatsheet.com/)
   - [Algorithm Visualizer](https://algorithm-visualizer.org/)


7) 재귀
   - Recursion: 함수가 자기 자신을 호출하는 것
   - 반복 구조를 단순화, 코드의 가독성을 높이고, 변수의 상태 변화로 인한 오류 방지
   - 스택: 함수 호출을 저장하는 메모리 공간, 재귀 사용시 과도하게 스택 메모리가 사용되지 않도록 주의


8) 병합 정렬
   - Merge Sort: 리스트를 반으로 나누어 각각 정렬한 후 병합하는 방식으로 정렬
   - 상한 O(n log n), 하한 Ω(n log n)
   - 재귀적으로 정렬을 수행하므로 스택 메모리 사용량이 높음
   - Theta(Θ): 상한과 하한이 같은 경우 사용

<details>
<summary>시간 복잡도 표</summary>

| 실행시간의 상한 | 알고리즘         |
|-----------------|--------------|
| O(n^2)          | 선택 정렬, 버블 정렬 |
| O(n log n)      | 병합 정렬        |
| O(n)            | 선형 검색        |
| O(log n)        | 이진 검색        |
| O(1)            |              |

| 실행시간의 하한 | 알고리즘         |
|-----------------|--------------|
| Ω(n^2)          | 선택 정렬        |
| Ω(n log n)      | 병합 정렬        |
| Ω(n)            | 버블 정렬        |
| Ω(log n)        |              |
| Ω(1)            | 선형 검색, 이진 검색 |


| 실행시간의 Θ    | 알고리즘      |
|-----------------|-----------|
| Θ(n^2)          | 선택 정렬     |
| Θ(n log n)      | 병합 정렬     |
| Θ(n)            |           |
| Θ(log n)        |           |
| Θ(1)            |           |

</details>

---

### 5. 메모리
1) 메모리 주소
   - 컴퓨터의 메모리에 저장된 데이터의 위치
   - 메모리 주소는 16진수로 표현
   - 0x: 16진수를 나타내는 접두사
   - `%p`: 메모리 주소를 출력하는 형식 지정자, `&n`: 변수 n의 주소를 반환, `*&n`: 변수 n의 주소에 저장된 값을 반환


2) 포인터
   - 포인터 변수: 메모리 주소를 저장하는 변수
   - 포인터 변수 선언: `int *p;`, 초기화: `int *p = &n;`, 주소: `&p`, 값: `*p`
   - 포인터 변수의 크기는 메모리 크기와 무관하게 컴파일러에 의해 결정, 64비트 컴퓨터에서 8바이트, 32비트 컴퓨터에서 4바이트


3) 문자열
   - CS50 라이브러리의 string 타입은 문자열의 주소를 저장하는 포인터를 미리 정의한 것
   - `typedef char *string;`: char * 타입의 포인터를 string이라는 새로운 타입으로 정의
   - `char *s = "JOHN";`: 첫 번째 문자 J의 메모리 주소를 포인터 s에 저장, 문자열이 메모리에서 연속된 바이트로 저장되어 있기 때문에 순차적 접근 가능


4) 문자열 비교
   - `==` 연산자로 두 문자열을 비교하면 메모리 주소가 같은지 비교
   - 포인터 연산: 포인터에 정수를 더하거나 뺄 수 있음, `s[1]`은 `*(s+1)`과 같음


5) 문자열 복사
   - 문자열 포인터를 다른 변수에 할당하면, 두 포인터는 같은 메모리 주소를 가리킴. 따라서 하나의 포인터를 통해 문자열을 수정하면, 같은 문자열을 참조하는 다른 포인터도 그 변경 사항을 반영
   - `malloc` 함수로 글자수 + 1(널 종단 문자('\0')) byte 만큼의 메모리 공간 할당 후 loop를 통해 문자열을 복사하면 두 문자열은 서로 다른 메모리 주소를 가짐
     - `malloc` 함수: 메모리 할당 함수, 동적으로 메모리를 할당하고 할당된 메모리의 첫 바이트 주소를 반환


6) 메모리 할당과 해제
   - 메모리 할당: 프로그램이 실행될 때 필요한 데이터를 저장하기 위해 메모리의 특정 공간을 예약하는 과정
   - 메모리 누수: 프로그램이 종료되어도 메모리가 해제되지 않아 메모리가 계속 쌓이는 현상
   - `free` 함수: 동적으로 할당된 메모리를 해제하는 함수, 메모리 누수를 방지
   - `valgrind`: 메모리 누수를 검사하는 도구
   - `sizeof` 연산자: 변수의 크기를 반환하는 연산자, `sizeof(int)`, `sizeof(char)`, `sizeof(float)` 등


7) 메모리 교환, 스택, 힙
   - 메모리 구조  : 코드 영역, 데이터 영역, 힙 영역, 스택 영역
     - 코드 영역: 프로그램의 코드가 저장되는 메모리 영역
     - 데이터 영역: 전역 변수, 정적 변수, 상수 등이 저장되는 메모리 영역
     - 힙 영역: 동적으로 할당된 메모리가 저장되는 메모리 영역
     - 스택 영역: 함수 호출 시 지역 변수, 매개변수, 함수의 반환 주소 등이 저장되는 메모리 영역  
     ![memory_layout](./img/memory_layout.png)
   - 메모리 영역 분할 이유: 효율적인 메모리 관리, 보안과 안정성, 성능 최적화 등
   - 기본 타입의 변수가 메서드에 전달될 때는 값이 복사되어 전달되지만, 포인터가 전달될 때는 메모리 주소가 전달되어 메모리를 공유하게 됨


8) 파일 쓰기
   - `scanf`: 사용자로부터 입력을 받는 함수, `scanf("%f %c %s", &a, &b, &c);`
     - 문자 배열의 이름을 변수로 사용하면 배열의 첫 번째 요소의 주소를 의미
   - 파일 입출력 함수: `fopen, fclose, fgetc, fputc, fgets, fputs, fprintf, fscanf` 등 
     - `fopen("file.txt", "w");`: file.txt 파일을 쓰기 모드로 열기
     - `r`: 읽기 모드, `w`: 쓰기 모드, `a`: 추가 모드 등
   - 메모리를 초과하면 스택 오버플로우, 힙 오버플로우, 버퍼 오버플로우 등의 문제가 발생


9) 파일 읽기
   - `unsigned char`: 1바이트 크기의 부호 없는 정수, 0 ~ 255 사이의 값을 저장
   - `fread`: 각 인자는 배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일을 의미
   - 매직 넘버: 파일의 형식을 나타내는 시작 부분에 있는 고유한 바이트 조합
   
<div style="margin-left: 40px;">
<details>
<summary>매직 넘버 표</summary>

  | 파일 형식 | 매직 넘버 (파일 시그니처)                                          |
  |-----------|----------------------------------------------------------|
  | JPEG      | `0xFF 0xD8 0xFF`                                         |
  | PNG       | `0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A`                |
  | GIF       | `0x47 0x49 0x46 0x38` (후속 바이트: `0x37` 또는 `0x39`)         |
  | PDF       | `0x25 0x50 0x44 0x46`                                    |
  | ZIP       | `0x50 0x4B 0x03 0x04`                                    |
  | RAR       | `0x52 0x61 0x72 0x21 0x1A 0x07 0x00`                     |
  | TAR       | `0x75 0x73 0x74 0x61 0x72`                               |
  | WAV       | `0x52 0x49 0x46 0x46` + 4 바이트 크기 + `0x57 0x41 0x56 0x45` |
  | MP3       | `0x49 0x44 0x33`                                         |

</details>
</div>

---
### 6. 자료구조
1) malloc과 포인터 복습
   - 초기화되지 않은 포인터는 쓰레기 값을 가질 수 도 있다. 잘못된 메모리 위치에 접근하게 되어 예상치 못한 동작이 발생 할 수 있다.  
   따라서 포인터를 사용하기 전에 초기화하는 것이 좋음.


2) 배열의 크기 조정하기
   - 배열의 크기를 조정하려면 새로운 배열을 할당하고 기존 배열의 값을 복사해야 함
   - insert O(n), search O(log n)
   - `realloc` 함수: 동적으로 할당된 메모리의 크기를 변경하는 함수
     - `realloc(ptr, size)`: ptr이 가리키는 메모리의 크기를 size로 변경


3) 연결 리스트: 도입
   - 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체
   - 연결 리스트: 데이터를 저장하는 노드들이 포인터로 연결된 자료구조
   - 노드: 데이터와 다음 노드를 가리키는 포인터로 구성, number는 각 node가 가지는 값, *next 는 다음 node를 가리키는 포인터  
     ```c
      typedef struct node
      {
          int number;
          struct node *next;
      }
      node;
      ```
     

4) 연결 리스트: 코딩
   - `n->number = 2;`: n이 가리키는 노드의 number 값, `(*n).number = 2;`와 같음


5) 연결 리스트: 시연
   - 배열과 비교해서 연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점
   - 구조가 정적인 배열과 달리 연결 리스트에서는 임의 접근이 불가능한 단점
   - 역동성: 프로그램이 실행 중에 데이터 구조를 변경할 수 있는 능력
   - insert O(n), search O(n)


6) 연결 리스트: 트리
   - 트리: 계층적인 데이터 구조, 루트 노드에서 시작하여 여러 노드로 확장되는 구조
   - 이진 탐색 트리(binary search tree): 각 노드가 최대 두 개의 자식 노드를 가지는 트리, 왼쪽 자식 노드는 부모 노드보다 작고 오른쪽 자식 노드는 부모 노드보다 큼
     - 정렬된 데이터를 다루거나 빠른 검색, 삽입, 삭제가 필요한 경우 매우 유용하지만, 트리가 편향되지 않도록 관리해야 한다는 점에서 복잡성이 증가
   - 연결 리스트에서의 각 노드들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성
   - 루트: 트리의 최상위 노드, 부모: 자식 노드를 가지는 노드, 자식: 부모 노드를 가지는 노드
   - insert O(log n), search O(log n)


7) 해시 테이블
   - 해시 함수를 사용해 데이터를 저장하고 검색하는 자료구조, 연결 리스트의 배열
     - 해시 함수: key를 입력받아 해시 테이블의 인덱스로 변환하는 역할, 제산법, 제곱법, 폴딩법, 기수변환법, 무작위법 등이 존재
   - 일반적으로는 O(1)의 시간 복잡도를 가지지만, 충돌이 발생하면 O(n)의 시간 복잡도를 가질 수 있음


8) 트라이
   - 기본적으로 트리 형태의 자료 구조, 각 노드가 배열로 이루어져 있음
   - 일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않은 상수값(예, 20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있다.
   - 문자열 검색에 효율적이나 메모리 사용량이 많다.
   - insert O(1), search O(1)


9) 스택, 큐, 딕셔너리
   - 큐(queue): 선입선출(FIFO) 구조, enqueue, dequeue 연산
   - 스택(stack): 후입선출(LIFO) 구조, push, pop 연산
   - 딕셔너리(dictionary): 키와 값을 저장하는 자료구조, 키를 해시 함수를 통해 해시값으로 변환하여 저장
   - 큐는 너비 우선 탐색, 스택은 함수 호출, 딕셔너리는 해시 테이블과 트라이 등에 사용
   - 큐는 데이터를 순서대로 처리, 스택은 메모리를 효율적으로 사용, 딕셔너리는 빠른 검색, 삽입, 삭제가 가능